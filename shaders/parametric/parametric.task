#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require

#include "../shaderInterface.h"
#include "../common.glsl"
#include "../culling.glsl"

// Task shader work group size: one thread per task
layout(local_size_x = 1) in;

// ============================================================================
// Task Payload
// ============================================================================

struct TaskPayload {
    vec3 position;      // Face center or vertex position
    vec3 normal;        // Face normal or vertex normal
    float area;         // Face area (used for scaling)
    uint taskId;        // Global element ID
    uint isVertex;      // 1 if vertex element, 0 if face element
    uint elementType;   // Parametric surface type
    uint resolutionM;   // Target M resolution
    uint resolutionN;   // Target N resolution
    uint deltaU;        // Tile size in U direction
    uint deltaV;        // Tile size in V direction
};

taskPayloadSharedEXT TaskPayload payload;

// ============================================================================
// Push Constants
// ============================================================================

layout(push_constant) uniform PushConstants {
    mat4 model;         // Model matrix
    uint nbFaces;       // Number of faces in mesh
    uint nbVertices;    // Number of vertices in mesh
    uint elementType;   // Parametric surface type (0=torus, 1=sphere, etc.)
    float userScaling;  // Global scale multiplier
    float torusMajorR;  // Torus major radius
    float torusMinorR;  // Torus minor radius
    float sphereRadius; // Sphere radius
    uint resolutionM;   // UV grid M resolution
    uint resolutionN;   // UV grid N resolution
    uint debugMode;     // Debug visualization mode
    uint enableCulling; // 0 = disabled, 1 = frustum culling
} push;

// ============================================================================
// View UBO (for frustum culling)
// ============================================================================

layout(set = SET_SCENE, binding = BINDING_VIEW_UBO) uniform ViewUBOBlock {
    mat4 view;
    mat4 projection;
    vec4 cameraPosition;
    float nearPlane;
    float farPlane;
} viewUBO;

// ============================================================================
// Amplification Function K
// ============================================================================

void getDeltaUV(uint M, uint N, out uint deltaU, out uint deltaV) {
    const uint maxVertices = 256;
    const uint maxPrimitives = 256;

    deltaU = M;
    deltaV = N;

    // Vertex constraint: (deltaU + 1) * (deltaV + 1) <= maxVertices
    uint numVerts = (deltaU + 1) * (deltaV + 1);
    if (numVerts > maxVertices) {
        uint maxDelta = uint(sqrt(float(maxVertices))) - 1;
        deltaU = min(deltaU, maxDelta);
        deltaV = min(deltaV, maxDelta);
    }

    // Primitive constraint: deltaU * deltaV * 2 <= maxPrimitives
    uint numPrims = deltaU * deltaV * 2;
    if (numPrims > maxPrimitives) {
        uint maxDelta = uint(sqrt(float(maxPrimitives) / 2.0));
        deltaU = min(deltaU, maxDelta);
        deltaV = min(deltaV, maxDelta);
    }

    deltaU = max(deltaU, 2u);
    deltaV = max(deltaV, 2u);
}

// ============================================================================
// Main: Mapping Function F with Amplification K and Culling
// ============================================================================

void main() {
    uint globalId = gl_WorkGroupID.x;

    bool isVertex = (globalId >= push.nbFaces);

    uint faceId = 0;
    uint vertId = 0;

    if (isVertex) {
        vertId = globalId - push.nbFaces;

        int edge = readVertexEdge(vertId);
        if (edge >= 0) {
            faceId = uint(readHalfEdgeFace(uint(edge)));
        } else {
            faceId = 0;
        }

        payload.position = readVertexPosition(vertId);
        payload.normal = readVertexNormal(vertId);
        payload.area = readFaceArea(faceId);
    } else {
        faceId = globalId;

        payload.position = readFaceCenter(faceId);
        payload.normal = readFaceNormal(faceId);
        payload.area = readFaceArea(faceId);
    }

    payload.taskId = globalId;
    payload.isVertex = isVertex ? 1u : 0u;
    payload.elementType = push.elementType;

    // Frustum culling
    bool isVisible = true;

    if (push.enableCulling == 1) {
        mat4 mvp = viewUBO.projection * viewUBO.view * push.model;
        float boundingRadius = computeBoundingRadius(payload.area, push.userScaling, 2.0);
        isVisible = isInFrustum(payload.position, boundingRadius, mvp, 0.1);
    }

    // Amplification
    uint M = push.resolutionM;
    uint N = push.resolutionN;

    payload.resolutionM = M;
    payload.resolutionN = N;

    uint deltaU, deltaV;
    getDeltaUV(M, N, deltaU, deltaV);

    payload.deltaU = deltaU;
    payload.deltaV = deltaV;

    uint numTilesU = (M + deltaU - 1) / deltaU;
    uint numTilesV = (N + deltaV - 1) / deltaV;

    // Emit mesh tasks (0 if culled)
    uint visible = isVisible ? 1u : 0u;
    EmitMeshTasksEXT(numTilesU * visible, numTilesV * visible, 1);
}
