#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require

#include "../shaderInterface.h"

layout(local_size_x = 1) in;
layout(max_vertices = 3, max_primitives = 1, triangles) out;

// Must match task shader payload
struct TaskPayload {
    vec3 position;
    vec3 normal;
    float area;
    uint taskId;
    uint isVertex;
    uint elementType;
    uint padding;
};

taskPayloadSharedEXT TaskPayload payload;

layout(location = 0) out vec4 vColor[];

layout(push_constant) uniform PushConstants {
    mat4 model;
    uint nbFaces;
    uint nbVertices;
    uint elementType;
    uint padding;
} push;

layout(set = SET_SCENE, binding = BINDING_VIEW_UBO) uniform ViewUBOBlock {
    mat4 view;
    mat4 projection;
    vec4 cameraPosition;
    float nearPlane;
    float farPlane;
} viewUBO;

void main() {
    SetMeshOutputsEXT(3, 1);

    mat4 mvp = viewUBO.projection * viewUBO.view * push.model;

    // Emit a small triangle at the element position for validation
    float size = sqrt(payload.area) * 0.1;
    vec3 p = payload.position;
    vec3 n = normalize(payload.normal);

    // Build a tangent frame from the normal
    vec3 helper = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 t = normalize(cross(helper, n));
    vec3 b = cross(n, t);

    vec3 v0 = p + t * size;
    vec3 v1 = p - t * 0.5 * size + b * 0.866 * size;
    vec3 v2 = p - t * 0.5 * size - b * 0.866 * size;

    gl_MeshVerticesEXT[0].gl_Position = mvp * vec4(v0, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = mvp * vec4(v1, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = mvp * vec4(v2, 1.0);

    // Color: green for face elements, blue for vertex elements
    vec4 color = payload.isVertex == 1u ? vec4(0.3, 0.5, 1.0, 1.0)
                                        : vec4(0.3, 1.0, 0.5, 1.0);
    vColor[0] = color;
    vColor[1] = color;
    vColor[2] = color;

    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
}
