#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require

#include "../shaderInterface.h"
#include "../common.glsl"
#include "parametricSurfaces.glsl"

// 32 threads for parallel vertex/primitive generation
layout(local_size_x = 32) in;

// Output limits: 8x8 grid = 81 verts, 128 tris
layout(max_vertices = 81, max_primitives = 128, triangles) out;

// Must match task shader payload
struct TaskPayload {
    vec3 position;
    vec3 normal;
    float area;
    uint taskId;
    uint isVertex;
    uint elementType;
    uint padding;
};

taskPayloadSharedEXT TaskPayload payload;

// Per-vertex outputs
layout(location = 0) out PerVertexData {
    vec4 worldPosU;  // xyz = world position, w = u coordinate
    vec4 normalV;    // xyz = world normal, w = v coordinate
} vOut[];

// Per-primitive outputs
layout(location = 2) perprimitiveEXT out PerPrimitiveData {
    flat uvec4 data;  // x = taskId, y = isVertex, z = elementType, w = unused
} pOut[];

layout(push_constant) uniform PushConstants {
    mat4 model;
    uint nbFaces;
    uint nbVertices;
    uint elementType;
    uint padding;
} push;

layout(set = SET_SCENE, binding = BINDING_VIEW_UBO) uniform ViewUBOBlock {
    mat4 view;
    mat4 projection;
    vec4 cameraPosition;
    float nearPlane;
    float farPlane;
} viewUBO;

void main() {
    // 8x8 grid for smooth torus geometry
    const uint M = 8;
    const uint N = 8;

    const uint numVerts = (M + 1) * (N + 1);  // 81
    const uint numQuads = M * N;               // 64
    const uint numPrims = numQuads * 2;        // 128

    SetMeshOutputsEXT(numVerts, numPrims);

    mat4 mvp = viewUBO.projection * viewUBO.view * push.model;
    uint localId = gl_LocalInvocationID.x;

    // Torus parameters (will come from UBO in Feature 3.4)
    const float majorR = 1.0;
    const float minorR = 0.3;

    // Scale factor from face area
    float scale = sqrt(payload.area) * 0.1;

    // Rotation to align torus Z-up with element normal
    mat3 rotation = alignRotationToVector(payload.normal);

    // Generate vertices in parallel
    for (uint i = localId; i < numVerts; i += 32) {
        uint u = i % (M + 1);
        uint v = i / (M + 1);
        vec2 uv = vec2(u, v) / vec2(M, N);

        // Evaluate parametric torus
        vec3 localPos, localNormal;
        parametricTorus(uv, localPos, localNormal, majorR, minorR);

        // Scale, rotate, translate
        localPos *= scale;
        vec3 worldPos = payload.position + rotation * localPos;
        vec3 worldNormal = rotation * localNormal;

        vOut[i].worldPosU = vec4(worldPos, uv.x);
        vOut[i].normalV = vec4(worldNormal, uv.y);
        gl_MeshVerticesEXT[i].gl_Position = mvp * vec4(worldPos, 1.0);
    }

    // Generate triangle indices in parallel
    for (uint q = localId; q < numQuads; q += 32) {
        uint qu = q % M;
        uint qv = q / M;

        uint v00 = qv * (M + 1) + qu;
        uint v10 = v00 + 1;
        uint v01 = v00 + (M + 1);
        uint v11 = v01 + 1;

        uint triId0 = 2 * q;
        uint triId1 = 2 * q + 1;

        gl_PrimitiveTriangleIndicesEXT[triId0] = uvec3(v00, v10, v11);
        gl_PrimitiveTriangleIndicesEXT[triId1] = uvec3(v00, v11, v01);

        pOut[triId0].data = uvec4(payload.taskId, payload.isVertex, payload.elementType, 0);
        pOut[triId1].data = uvec4(payload.taskId, payload.isVertex, payload.elementType, 0);
    }
}
